ICS 53
HW 4
1. (30 points) Write a C program, called execute, that reads a one line Bash command from the standard input and executes the program, given in the first word of a line, passing in the arguments, given as the rest of the words on the command line.  The program should search down the PATH variable to find the full path of the executable before running it.  You will call execvpe() with appropriate arguments. Here is some sample runs:
        echo /bin/echo hello world | execute
echo which ls echo login | execute
execute < my_command
where my_command contains
ls -lR /usr
1. (30 pts) Unix process creation: Write a program, called my_fork, that uses fork() to create a total of 4 processes - each printing one letter of the alphabet from A to D K times.  K will be a command argument, but should default to 10000.  Have each process print it's process id (PID) when it is created. Also have each process flush the output after printing each character with fflush(stdout). Read about fork() in man or google.  Be sure you do not leave any processes running.  You can check this with the command, ps -ef or ps aux. Note a parent process must wait() for each child after it has terminated, or that child will become a zombie. Here is an example call (note the letters should be a jumbled mess and should be different order every time you call your program).
                $ my_fork 10
                AAAAAABBBBBBBCDCDCDCDCDCDCBBBDCDCAAAADCD
1. (40 pts) UNIX I/O Exercise: The purposes of this assignment are (1) to become familiar with UNIX I/O system calls and (2) to see the difference in performance between C library functions and system calls.  The program you write should do the following.
      * Contain a main program that prints out the time to copy the file using each of three methods.  The name of the input file and the name of the output file should come from the command line arguments to your program (via argv).
      * Method 1: Implement a function that uses fopen(), fgetc() and fputc(), then fclose() to copy the input file to the output file one character at a time. Each loop iteration will read and write a single character but I/O will be buffered by the stdio library routines which make system calls read() and write() to fill or flush the stdio buffers.
      * Method 2: Implement a function that uses the system calls open(), read() and write(), then close() to copy the input file to the output file one character at a time. Each loop iteration will read and write just a single character.  There will be no buffering because you will be making system calls to read and write each character.
      * Method 3: Implement a function that uses the system calls open(), read() and write(), then close() to copy the input file to the output file one buffer at a time (the buffer should be of size "BUFSIZ", which is declared in the <stdio.h> include file and each read or write should write as many characters as possible per loop iteration up to BUFSIZ).
      * Once these functions are implemented, test them out by having them perform their work N times each (where N is a command-line argument).  Display the amount of wallclock, user, and system time it takes for each of the three method functions to execute.
      * Use a Timer to measure the performance of each of the three approaches to copying a file.  Use /usr/share/dict/linux.words for the input file to copy.  Here is a Timer you may use. There is an example of use at the bottom https://docs.google.com/document/d/1KY2DuvijtOKs7B4zlLK18lhBLdg1UDUtim8k5Bphudc/edit?usp=sharing (Some classmates helped fix the two errors, so it should compile and run correctly now.  Thanks to those who helped! -10 points for Dr Klefstad ;-) )  You must split this file into Timer.h and Timer.c as described in the comment at the top, then compile Timer.c with -c option to create Timer.o which you can link in with your program that uses the timer. Your program that uses the Timer must #include “Timer.h”
      * Your program will take three arguments: argv[1] will be a number 1, 2, or 3 indicating which of the above methods your program should use to make the copy; argv[2] will be the input file name; argv[3] will be the output file name. A given invocation of your program should make one copy using the method passed in for argv[1].  The output should be just the time required to make the copy.  To ensure you measure just the file copy in each case, start the timer (with Timer_init()) right before you start the copy but after you have open()ed the files and stop the timer (or get the elapsed user time) just after you have copied the last item from the file but before close()ing of the files.  Print the elapsed user time(to stdout) after you close the output files.